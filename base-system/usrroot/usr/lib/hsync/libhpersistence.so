#!/bin/bash


# This is the first execution of hsync, here we don't have a current state.
# It is 'none', so in this part we need to either set a previous persistent state
# or set 'always' mode if no other state is available.
start_persistence(){

	case $STATE_MODE in
		# If there's no STATE_MODE, then there was no persistence set.
		# Let's clean the partition and start the always mode
		"")
			log "No previous state found, creating new persistence in always mode"
			start_always_mode || return 1 # error
			return 0 # sucess
			;;

		# If the state was always, then let's restore the files
		"always")
			log "Previous state found, restoring persistence in always mode"
			restore_always_mode || return 1
			return 0 # sucess
			;;

		# If the state was event, then let's restore the files
		"event")
			log "Previous state found, restoring persistence in event mode"
			restore_event_mode || return 1
			return 0 # sucess
			;;

		# If the state was contest, then let's restore the files
		"event")
			log "Previous state found, restoring persistence in contest mode"
			restore_contest_mode || return 1
			return 0 # sucess
			;;
	esac
		
	return 0
}

# This function is supposed to be called when there's a mode already set,
# so that this function only change the persistence between modes.
apply_persistence_mode(){

	if ! system_has_persistece_enabled; then
		STATE_IS_PERSISTENCE_ENABLED="false"
		return 0 #success
	fi

	## Check if the current state is the same as the directives specified mode.
	if is_running_mode_same_as_new_mode; then
		log "+The following mode timeframes are considered to be the same:
		#1: $STATE_MODE 
		    $STATE_MODE_START_TIME_UTC - $STATE_MODE_END_TIME_UTC
		#2: $NEW_MODE 
		    $NEW_MODE_START_TIME_UTC - $NEW_MODE_END_TIME_UTC
		No modification will be done on persistence, preserving changes."
		return 0 # success. 
	else
		log "+The following mode timeframes are considered to be the different:
		#1: $STATE_MODE 
		    $STATE_MODE_START_TIME_UTC - $STATE_MODE_END_TIME_UTC
		#2: $NEW_MODE 
		    $NEW_MODE_START_TIME_UTC - $NEW_MODE_END_TIME_UTC
		Modifications to persistence will be done."
	fi

	#set -x
	[ "$STATE_MODE" = "always" ]	&& [ "$NEW_MODE" = "event" ]	&& always_to_event
	[ "$STATE_MODE" = "always" ]	&& [ "$NEW_MODE" = "contest" ]	&& always_to_contest
	[ "$STATE_MODE" = "event" ]		&& [ "$NEW_MODE" = "always" ]	&& event_to_always
	[ "$STATE_MODE" = "event" ]		&& [ "$NEW_MODE" = "event" ]	&& event_to_event
	[ "$STATE_MODE" = "event" ]		&& [ "$NEW_MODE" = "contest" ]	&& event_to_contest
	[ "$STATE_MODE" = "contest" ]	&& [ "$NEW_MODE" = "always" ]	&& contest_to_always
	[ "$STATE_MODE" = "contest" ]	&& [ "$NEW_MODE" = "event" ]	&& contest_to_event
	[ "$STATE_MODE" = "contest" ]	&& [ "$NEW_MODE" = "contest" ]	&& contest_to_contest
	#set +x

	STATE_IS_PERSISTENCE_ENABLED="true"
	[ "$NEW_MODE" = "always" ] && STATE_PERSISTENCE_DISK="event"
	[ "$NEW_MODE" = "event" ] && STATE_PERSISTENCE_DISK="event"
	[ "$NEW_MODE" = "contest" ] && STATE_PERSISTENCE_DISK="contest"

	log_aufs_branches

	return 0
}

## Given a persistent branch currently part of the AUFS union
#  let it be free. That is, removing the branch from the union.
# $1 = Branch to free
free_branch(){
	local BRANCH PIDS PID
	BRANCH="$1"

	## First, let's quit all the modules as they may lock the persistent branch
	hmm -f --block-update /etc/hmm/any

	## Now, we will stop the user interface as budgie regulary keep cache files that locks the branch
	systemctl stop lightdm.service
	sleep 5

	## Let's try to remove the branch from AUFS
	mount -t aufs -o remount,del:"$BRANCH" aufs / 2>/dev/null
	[ $? -eq 0 ] && return 0

	## Ok, we cannot remove the AUFS branch, so, a non-graphical process is locking the branch
	# we will try killing all processes that are locking them. If huronOS is well configured,
	# any important process should be locking the branch
	while : ; do
		PIDS=$(aubusy -v / $BRANCH | awk '{print $1}' | sort | uniq | sed 's:\n: :g')
		for PID in $PIDS; do
			echo "Killing process with ID $PID aka. $(ps -p $PID -o command --no-headers | awk '{print $1}')"
			kill -9 $PID >/dev/null 2>/dev/null
		done
		## Let's retry to remove the branch
		mount -t aufs -o remount,del:"$BRANCH" aufs / 2>/dev/null
		[ $? -eq 0 ] && return 0 # We are free!!
	done
}

## Branch is unified into AUFS and then realeased for user to use.
# $1 = Branch to release
release_branch(){
	local BRANCH
	BRANCH="$1"

	mount -t aufs -o remount,prepend:"$BRANCH" aufs /
	systemctl start lightdm.service
}

## Cleans the given partition of ANY file, then creates the base dirs that will redirect
# the AUFS tdp create policy to save changes on usrchanges instead of syschanges
# $1 = Mount point to clean, should be writtable
prepare_perch(){
	local DIR
	DIR="$1"

	## Clean directory
	chattr -R -i $DIR
	chown -R root:root $DIR
	rm -rf $DIR/* 2>/dev/null || true
	rm -rf $DIR/.* 2>/dev/null || true

	## By doing this, all the files created under this directories will be saved on usrchanges/
	# Also, because all the modules/ are mounted between syschanges/ on the low, and usrchanges/ on the top
	# the files modified or edited by the software modules will be copied up to the bottom-up writtable branch
	# of where the file was located, so, only usrchages/ is rw. Then software preferences should be sorted here.
	mkdir -p $DIR/home/contestant/{Desktop,Documents,Downloads,Music,Pictures,Public,Templates,Videos,.config,.local}
	chown -R contestant:contestant $DIR
}

## Saves the changes of a partition on the selected directory with the date and hour stamp
# $1 = partition mount point
# $2 = destiny directory to save
# $3 = preffix of directory where changes will be saved
save_changes(){
	local ORIGIN DESTINY PREFFIX DIR
	ORIGIN="$1"
	DESTINY="$2"
	PREFFIX="$3"
	DIR="$DESTINY/$PREFFIX-$(date '+%Y-%m-%d_%H.%M')"

	mkdir -p $DIR
	cp -rf --verbose $ORIGIN/* $DIR/
	chown contestant:contestant $DIR
}

start_always_mode(){
	# Let's deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind $EVENT_MNT $USRCHANGES

	## Clean the disk, create base directory tree to allow AUFS copyup policy
	prepare_perch $USRCHANGES

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:$USRCHANGES aufs /

	## Let's notify the state that we're setting
	STATE_MODE="always"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	return 0
}

restore_always_mode(){
	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind $EVENT_MNT $USRCHANGES

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:$USRCHANGES aufs /

	## Let's notify the state that we're setting
	STATE_MODE="always"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	return 0
}

restore_event_mode(){
	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind $EVENT_MNT $USRCHANGES

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:$USRCHANGES aufs /

	## Let's notify the state that we're setting
	STATE_MODE="event"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	return 0
}

restore_contest_mode(){
	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind $CONTEST_MNT $USRCHANGES

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:$USRCHANGES aufs /

	## Let's notify the state that we're setting
	STATE_MODE="contest"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="contest"

	log_aufs_branches
	return 0
}

always_to_event(){
	free_branch $USRCHANGES
	prepare_perch $USRCHANGES
	release_branch $USRCHANGES
	return 0
}

always_to_contest(){
	free_branch $USRCHANGES
	umount $USRCHANGES
	prepare_perch $CONTEST_MNT
	mount --bind $CONTEST_MNT $USRCHANGES
	release_branch $USRCHANGES
	return 0
}

event_to_always(){
	free_branch $USRCHANGES
	prepare_perch $USRCHANGES
	release_branch $USRCHANGES
	return 0
}

event_to_event(){
	free_branch $USRCHANGES
	prepare_perch $USRCHANGES
	release_branch $USRCHANGES
	return 0
}

event_to_contest(){
	free_branch $USRCHANGES
	umount $USRCHANGES
	prepare_perch $CONTEST_MNT
	mount --bind $CONTEST_MNT $USRCHANGES
	release_branch $USRCHANGES
	return 0
}

contest_to_always(){
	free_branch $USRCHANGES
	umount $USRCHANGES
	prepare_perch $EVENT_MNT
	save_changes $CONTEST_MNT "$EVENT_MNT/home/contestant" "contest"
	prepare_perch $CONTEST_MNT
	mount --bind $EVENT_MNT $USRCHANGES
	release_branch $USRCHANGES
	return 0
}

contest_to_event(){
	free_branch $USRCHANGES
	umount $USRCHANGES
	prepare_perch $EVENT_MNT
	save_changes $CONTEST_MNT "$EVENT_MNT/home/contestant" "contest"
	prepare_perch $CONTEST_MNT
	mount --bind $EVENT_MNT $USRCHANGES
	release_branch $USRCHANGES
	return 0
}

contest_to_contest(){
	free_branch $USRCHANGES
	save_changes $CONTEST_MNT "$EVENT_MNT/home/contestant" "contest"
	prepare_perch $USRCHANGES
	release_branch $USRCHANGES
	return 0
}

