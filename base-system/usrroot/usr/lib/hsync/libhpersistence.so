#!/bin/bash

# ## Set some constants
# readonly MEMORY=/run/initramfs/memory
# readonly SYSTEM_MNT=$MEMORY/system
# readonly EVENT_MNT=$MEMORY/event
# readonly CONTEST_MNT=$MEMORY/contest
# readonly SYSCHANGES=$MEMORY/syschanges
# readonly USRCHANGES=$MEMORY/usrchanges
# readonly BASE_MNT=$MEMORY/base
# readonly MODULES_MNT=$MEMORY/modules
# readonly UNION=/
# readonly DIRECTIVES_FILE=/etc/hsync/directives
# readonly DIRECTIVES_FILE_SERVER=/etc/hsync/server
# readonly STATE_FILE=/etc/hsync/state
# readonly BACKUP_DIR_NAME=.huronOS..sysbackup.d
# readonly BACKUP_DIR=$USRCHANGES/$BACKUP_DIR_NAME


# ## Set some global variables
# declare STATE_IS_CLOCK_SYNC
# declare STATE_MODE
# declare STATE_MODE_START_TIME_UTC
# declare STATE_MODE_END_TIME_UTC
# declare STATE_IS_PERSISTENCE_ENABLED
# declare STATE_PERSISTENCE_DISK
# declare STATE_LAST_HSYNC_EXECUTION_TIME_UTC

# declare DIRECTIVES_FILE_URL
# declare DIRECTIVES_TEMP_FILE
# declare DIRECTIVES_HAVE_CHANGED
# declare DIRECTIVES_GLOBAL_CONFIG_HAVE_CHANGED
# declare DIRECTIVES_ALWAYS_CONFIG_HAVE_CHANGED
# declare DIRECTIVES_EVENT_CONFIG_HAVE_CHANGED
# declare DIRECTIVES_CONTEST_CONFIG_HAVE_CHANGED
# declare DIRECTIVES_EVENT_TIMES_HAVE_CHANGED
# declare DIRECTIVES_CONTEST_TIMES_HAVE_CHANGED

## Cleans the given partition of ANY file, then creates the base dirs that will redirect
# the AUFS tdp create policy to save changes on usrchanges instead of syschanges
# $1 = Mount point to clean, should be writtable
prepare_perch(){
	local DIR
	DIR="$1"

	## Clean directory
	chattr -R -i $DIR
	chown -R root:root $DIR
	rm -rf $DIR/* 2>/dev/null || true
	rm -rf $DIR/.* 2>/dev/null || true

	## By doing this, all the files created under this directories will be saved on usrchanges/
	# Also, because all the modules/ are mounted between syschanges/ on the low, and usrchanges/ on the top
	# the files modified or edited by the software modules will be copied up to the bottom-up writtable branch
	# of where the file was located, so, only usrchages/ is rw. Then software preferences should be sorted here.
	mkdir -p $DIR/home/contestant/{Desktop,Documents,Downloads,Music,Pictures,Public,Templates,Videos,.config,.local}
	chown -R contestant:contestant $DIR
}


start_always_mode(){
	# Let's deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind $EVENT_MNT $USRCHANGES

	## Clean the disk, create base directory tree to allow AUFS copyup policy
	prepare_perch $USRCHANGES

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:$USRCHANGES aufs /

	## Let's notify the state that we're setting
	STATE_MODE="always"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	return 0
}

restore_always_mode(){
	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind $EVENT_MNT $USRCHANGES

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:$USRCHANGES aufs /

	## Let's notify the state that we're setting
	STATE_MODE="always"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	return 0
}

restore_event_mode(){
	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind $EVENT_MNT $USRCHANGES

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:$USRCHANGES aufs /

	## Let's notify the state that we're setting
	STATE_MODE="event"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="event"

	log_aufs_branches
	return 0
}

restore_contest_mode(){
	# Silently deactivate all modules to prevent syschanges/ to stay at a higher index layer
	# than any module. That would cause that modularized-software changes to be saved
	# on the syschanges/ instead of the usrchanges/
	hmm -f --block-update /etc/hmm/any

	## Bind the mount to the usrchanges as an intermediate layer.
	mount --bind $CONTEST_MNT $USRCHANGES

	# At this moment, usrchanges/ branch is not used by anyone so we should be able to
	# prepend it without needing to restart any graphical service.
	mount -t aufs -o remount,prepend:$USRCHANGES aufs /

	## Let's notify the state that we're setting
	STATE_MODE="contest"
	STATE_MODE_START_TIME_UTC=""
	STATE_MODE_END_TIME_UTC=""
	STATE_IS_PERSISTENCE_ENABLED="true"
	STATE_PERSISTENCE_DISK="contest"

	log_aufs_branches
	return 0
}

# This is the first execution of hsync, here we don't have a current state.
# It is 'none', so in this part we need to either set a previous persistent state
# or set 'always' mode if no other state is available.
start_persistence(){

	case $STATE_MODE in
		# If there's no STATE_MODE, then there was no persistence set.
		# Let's clean the partition and start the always mode
		"")
			log "No previous state found, creating new persistence in always mode"
			start_always_mode || return 1 # error
			return 0 # sucess
			;;

		# If the state was always, then let's restore the files
		"always")
			log "Previous state found, restoring persistence in always mode"
			restore_always_mode || return 1
			return 0 # sucess
			;;

		# If the state was event, then let's restore the files
		"event")
			log "Previous state found, restoring persistence in event mode"
			restore_event_mode || return 1
			return 0 # sucess
			;;

		# If the state was contest, then let's restore the files
		"event")
			log "Previous state found, restoring persistence in contest mode"
			restore_contest_mode || return 1
			return 0 # sucess
			;;
	esac
		
	return 0
}